////
Copyright 2024 Peter Dimov
Distributed under the Boost Software License, Version 1.0.
https://www.boost.org/LICENSE_1_0.txt
////

[#ref_hash_append]
# <boost/hash2/hash_append.hpp>
:idprefix: ref_hash_append_

```
#include <boost/hash2/flavor.hpp>

namespace boost {
namespace hash2 {

template<class Hash, class Flavor = default_flavor, class T>
constexpr void hash_append( Hash& h, Flavor const& f, T const& v );

template<class Hash, class Flavor = default_flavor, class It>
constexpr void hash_append_range( Hash& h, Flavor const& f, It first, It last );

template<class Hash, class Flavor = default_flavor, class T>
constexpr void hash_append_size( Hash& h, Flavor const& f, T const& v );

template<class Hash, class Flavor = default_flavor, class It>
constexpr void hash_append_sized_range( Hash& h, Flavor const& f, It first, It last );

template<class Hash, class Flavor = default_flavor, class It>
constexpr void hash_append_unordered_range( Hash& h, Flavor const& f, It first, It last );

struct hash_append_tag;

} // namespace hash2
} // namespace boost
```

## hash_append

```
template<class Hash, class Flavor = default_flavor, class T>
constexpr void hash_append( Hash& h, Flavor const& f, T const& v );
```

Appends the representation of `v` to the message stored in `h`.

## hash_append_range

```
template<class Hash, class Flavor = default_flavor, class It>
constexpr void hash_append_range( Hash& h, Flavor const& f, It first, It last );
```

Appends the representations of the elements of the range `[first, last)` to the message stored in `h`.

Requires: ::
  `It` must be an _iterator_ type. `[first, last)` must be a valid _iterator range_.

Effects: ::
  * If `It` is `T*` and `is_contiguously_hashable<T, Flavor::byte_order>::value` is `true`, calls `h.update( first, (last - first) * sizeof(T) );`.
  * Otherwise, for each iterator `i` in `[first, last)`, calls `hash_append(h, f, v);`, where `v` is `*i`, implicitly converted to `std::iterator_traits<It>::value_type const&`.

Remarks: ::
+
If `hash_append_range` is called in a constant expression, the contiguously hashable optimization is only applied for `unsigned char*` and `unsigned char const*`.
+
`*i` is converted to a reference to the iterator `value_type` to handle the case when its `reference` is a proxy type, for example, when the iterator is `std::vector<bool>::iterator`.

## hash_append_size

```
template<class Hash, class Flavor = default_flavor, class T>
constexpr void hash_append_size( Hash& h, Flavor const& f, T const& v );
```

Appends the representation of `v`, converted to `Flavor::size_type`, to the message stored in `h`.

## hash_append_sized_range

```
template<class Hash, class Flavor = default_flavor, class It>
constexpr void hash_append_sized_range( Hash& h, Flavor const& f, It first, It last );
```

Appends the representations of the elements of the range `[first, last)`, followed by the size of the range, to the message stored in `h`.

## hash_append_unordered_range

```
template<class Hash, class Flavor = default_flavor, class It>
constexpr void hash_append_unordered_range( Hash& h, Flavor const& f, It first, It last );
```

Constructs a value from the representations of the elements of the range `[first, last)`, in a way such that their order doesn't affect the result, then appends that value, followed by the size of the range, to the message stored in `h`.

## hash_append_tag

```
struct hash_append_tag
{
};
```

`hash_append_tag` is a tag type used as the first argument of a `tag_invoke` overload to identify the `hash_append` operation.

